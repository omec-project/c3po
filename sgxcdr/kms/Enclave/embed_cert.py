'''
 Copyright 2019-present Open Networking Foundation
 SPDX-License-Identifier: Apache-2.0
'''
"""
A script to generate c/c++ header file for certificate bundles.
This will read one or more certificate files and embed them as 
string in header file.

Command line usage: please use -h option for help screen

Examples:

1) python embed_cert.py -c ./ca-bundle.crt ./test.pem 
        -e 36fb2eccd79ef59f72aeb806deb7052c38a1f75620f8fc8d947d855d638fd369 
        -s 63ef969cbc34ee465f277cd3c27e9b3c681d743e455f899daced1b3cf85ceb8f 
        -i 0
    => This will print header file on the stdout

2) python embed_cert.py -c ./ca-bundle.crt ./test.pem 
        -e 36fb2eccd79ef59f72aeb806deb7052c38a1f75620f8fc8d947d855d638fd369 
        -s 63ef969cbc34ee465f277cd3c27e9b3c681d743e455f899daced1b3cf85ceb8f 
        -i 0 -f ca_bundle.h
    => This will generate ca_bundle.h file with certificated embedded as string 
            from test.pem and ca-bundle.crt
"""

import os
import sys

from cryptography import x509
from cryptography.hazmat.backends import default_backend

from string import Template
import argparse
from traceback import print_exc

# header file template
TEMPLATE_STRING = '''// auto generated by embed-cert.py

#ifndef MBEDTLS_EXAMPLE_TRUSTED_CERTS_H
#define MBEDTLS_EXAMPLE_TRUSTED_CERTS_H

#define mozilla_ca_bundle \\
${CA_CERTS}

// needed for KMS Platform Verification 
#define KMS_MRENCLAVE "${KMS_MRENCLAVE}"
#define KMS_MRSIGNER "${KMS_MRSIGNER}"
#define KMS_ISVSVN "${KMS_ISVSVN}"

#endif
'''


# read single cert file and strinfy it
def stringing_single_cert(cert_file):
    single_cert = ''
    line_fmt = '\"%s\\r\\n\"\\'

    # parse certificate line by line
    with open(cert_file) as certfile:
        pem_data = certfile.read()

        # check for valid pem format
        try:
            cert_obj = x509.load_pem_x509_certificate(pem_data, default_backend())
        except ValueError as ve:
            return None

        for line in pem_data.split('\n'):
            line = line.strip()
            defline = line_fmt % line
            single_cert = single_cert + defline + '\n'

    # add cert file name as an identifier
    header = line_fmt % os.path.basename(cert_file) + '\n'
    header = header + line_fmt % ('=' * (len(header) - 8)) + '\n'
    single_cert = header + single_cert

    # return stringified certificate
    return single_cert


# combine more than one certificates into string
def stringing_multiple_cert(cert_dir):
    multiple_certs = ''

    # list files from directory
    abs_path = os.path.abspath(cert_dir.strip())
    for cert_file in os.listdir(abs_path):
        cert = stringing_single_cert(os.path.join(abs_path, cert_file))
        if cert:
            multiple_certs = multiple_certs + cert
        else:
            print("Warning: skipping embedding for cert %s due to wrong format" 
                  % cert_file)

    if len(multiple_certs) <= 2:
        return ''

    # remove last '\' but not the new line character
    if multiple_certs[-2] == '\\':
        multiple_certs = multiple_certs[:-2] + '\n'

    return multiple_certs


# generate header file using cert strings and other parameters like MRENCLAVE etc.
def generate_deffile(mrenclave, mrsigner, isvsvn, cert_files):
    ca_certs = stringing_multiple_cert(cert_files)
    if len(ca_certs) <= 0:
        raise Exception('Error: no certificates parase successfully to embed in CA bundle')

    s = Template(TEMPLATE_STRING)
    defstr = s.substitute(KMS_MRENCLAVE=mrenclave.strip(),
                           KMS_MRSIGNER=mrsigner.strip(),
                           KMS_ISVSVN=isvsvn.strip(),
                           CA_CERTS=ca_certs
                        )

    return defstr


# parse command line arguments.
def argument_parser(rawargs):
    parser = argparse.ArgumentParser(description='Generate CA bundle def file from cert files',
            formatter_class=lambda prog: argparse.HelpFormatter(prog, max_help_position=30, width=100),
            fromfile_prefix_chars='@')
    parser.add_argument('-c', '--certs', type=str,
            help='specify directory where certificates are stored')
    parser.add_argument('-e', '--mrenclave', type=str, 
            help='MRENCLAVE value for KMS')
    parser.add_argument('-s', '--mrsigner', type=str, 
            help='MRSIGNER value for KMS')
    parser.add_argument('-i', '--isvsvn', type=str, default='0', 
            help='ISVSVN value for KMS. [Default: 0]')
    parser.add_argument('-f', '--outfile', type=str, default='stdout',
            help='output file name. [Default: stdout]')

    args = parser.parse_args(rawargs)

    return args

# this function can also be used from other modules, if this is not the main script.
#  e.g. import embed_cert; embed_cert.main(['-c', './test.pem', '-s', 'signer', '-e', 'enclave', '-i', '0'])


def main(rawargs):
    if len(rawargs) == 0:
        rawargs = ['-h']
    args = argument_parser(rawargs)
    print(args)

    try:
        defstr = generate_deffile( args.mrenclave, args.mrsigner, args.isvsvn, args.certs)
        if args.outfile == 'stdout':
            sys.stdout.write(defstr)
        else:
            with open(args.outfile.strip(), 'w') as f:
                f.write(defstr)
    except Exception as excp:
        print('embed_cert.py: %s' % excp)
        sys.exit(1)

    sys.exit(0)

if __name__ == '__main__':
    main(sys.argv[1:])
